%==========================================================================
% FORENSIC EVIDENCE ACQUISITION SYSTEM (FEAS)
% Comprehensive Technical Documentation
% Version 1.0.0
%==========================================================================

\documentclass[12pt,a4paper]{report}

%==========================================================================
% PACKAGES
%==========================================================================
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{tocloft}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage{float}
\usepackage{enumitem}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{amsmath}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{array}
\usepackage{multicol}
\usepackage{makecell}
\usepackage{pifont}

\usetikzlibrary{shapes.geometric, arrows, positioning, calc, fit, backgrounds}
\pgfplotsset{compat=1.18}

%==========================================================================
% DOCUMENT CONFIGURATION
%==========================================================================
\geometry{
    left=2.5cm,
    right=2.5cm,
    top=3cm,
    bottom=3cm,
    headheight=14.5pt
}

% Colors
\definecolor{primaryblue}{HTML}{1a365d}
\definecolor{secondaryblue}{HTML}{2c5282}
\definecolor{accentblue}{HTML}{3182ce}
\definecolor{successgreen}{HTML}{276749}
\definecolor{warningorange}{HTML}{c05621}
\definecolor{errorred}{HTML}{c53030}
\definecolor{lightgray}{HTML}{f7fafc}
\definecolor{codebg}{HTML}{1a202c}
\definecolor{codefg}{HTML}{e2e8f0}

% Hyperref setup
\hypersetup{
    colorlinks=true,
    linkcolor=primaryblue,
    filecolor=secondaryblue,
    urlcolor=accentblue,
    pdftitle={FEAS Technical Documentation},
    pdfauthor={FEAS Development Team},
    pdfsubject={Digital Forensics Platform Documentation},
    pdfkeywords={forensics, evidence, acquisition, digital, investigation}
}

% Code listing style
\lstdefinestyle{codestyle}{
    backgroundcolor=\color{lightgray},
    commentstyle=\color{successgreen}\itshape,
    keywordstyle=\color{primaryblue}\bfseries,
    numberstyle=\tiny\color{secondaryblue},
    stringstyle=\color{warningorange},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    frame=single,
    rulecolor=\color{secondaryblue},
    framesep=5pt
}

\lstdefinestyle{bashstyle}{
    backgroundcolor=\color{codebg},
    basicstyle=\ttfamily\footnotesize\color{codefg},
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=none,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    frame=single,
    rulecolor=\color{primaryblue},
    framesep=5pt
}

\lstset{style=codestyle}

% Header and Footer
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\leftmark}
\fancyhead[R]{\textbf{FEAS v1.0.0}}
\fancyfoot[C]{\thepage}
\fancyfoot[R]{\textit{Confidential}}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

% Chapter title format
\titleformat{\chapter}[display]
{\normalfont\huge\bfseries\color{primaryblue}}
{\chaptertitlename\ \thechapter}{20pt}{\Huge}

\titleformat{\section}
{\normalfont\Large\bfseries\color{secondaryblue}}
{\thesection}{1em}{}

\titleformat{\subsection}
{\normalfont\large\bfseries\color{accentblue}}
{\thesubsection}{1em}{}

%==========================================================================
% DOCUMENT BEGIN
%==========================================================================
\begin{document}

%==========================================================================
% TITLE PAGE
%==========================================================================
\begin{titlepage}
    \centering
    \vspace*{2cm}
    
    {\Huge\bfseries\color{primaryblue} FORENSIC EVIDENCE\\[0.3cm] ACQUISITION SYSTEM\\[0.5cm]}
    {\LARGE\color{secondaryblue} (FEAS)}
    
    \vspace{1.5cm}
    
    {\Large\bfseries Technical Documentation}
    
    \vspace{0.5cm}
    
    {\large Version 1.0.0}
    
    \vspace{2cm}
    
    % Logo placeholder - can be replaced with actual logo
    \begin{tikzpicture}
        \draw[primaryblue, line width=3pt] (0,0) circle (2cm);
        \draw[secondaryblue, line width=2pt] (0,0) circle (1.5cm);
        \node[primaryblue, font=\Huge\bfseries] at (0,0) {FEAS};
    \end{tikzpicture}
    
    \vspace{2cm}
    
    {\Large\bfseries Development Team}
    
    \vspace{0.5cm}
    
    \begin{tabular}{c}
        \textbf{Rana Uzair Ahmad} \\[0.2cm]
        \textbf{Muhammad Usman} \\[0.2cm]
        \textbf{Umae Habiba} \\[0.2cm]
        \textbf{Hoor ul Ain} \\[0.2cm]
        \textbf{Bilal Badar} \\
    \end{tabular}
    
    \vfill
    
    {\large\today}
    
    \vspace{1cm}
    
    {\small\color{errorred}\textbf{CONFIDENTIAL - LAW ENFORCEMENT USE ONLY}}
\end{titlepage}

%==========================================================================
% TABLE OF CONTENTS
%==========================================================================
\tableofcontents
\newpage

\listoffigures
\newpage

\listoftables
\newpage

%==========================================================================
% CHAPTER 1: INTRODUCTION
%==========================================================================
\chapter{Introduction}

\section{Project Overview}

The \textbf{Forensic Evidence Acquisition System (FEAS)} is a comprehensive, full-stack digital forensics platform designed for law enforcement agencies and digital forensic investigators. It automates the acquisition, preservation, and analysis of digital evidence from social media platforms and local files while maintaining strict integrity through cryptographic hashing and an immutable chain of custody.

\subsection{Purpose}

FEAS addresses the critical need for a reliable, legally admissible evidence acquisition tool that:

\begin{itemize}[leftmargin=*]
    \item Automates evidence collection from social media platforms (Twitter/X, YouTube, Facebook, Instagram)
    \item Maintains cryptographic integrity verification using SHA-256 hashing
    \item Provides an immutable, append-only chain of custody log
    \item Generates professional PDF forensic reports
    \item Supports multiple storage backends (local filesystem, AWS S3)
    \item Offers a modern, user-friendly web interface
\end{itemize}

\subsection{Scope}

This documentation covers:

\begin{enumerate}[leftmargin=*]
    \item System architecture and design principles
    \item Installation and configuration procedures
    \item URL acquisition workflow
    \item File upload processing
    \item PDF report generation
    \item API reference
    \item Security considerations
    \item Troubleshooting guide
\end{enumerate}

\section{Key Features}

\begin{table}[H]
\centering
\caption{FEAS Key Features Overview}
\label{tab:features}
\begin{tabularx}{\textwidth}{|l|X|}
\hline
\textbf{Feature} & \textbf{Description} \\
\hline
Secure Authentication & JWT token-based auth with bcrypt password hashing \\
\hline
Universal Acquisition & Capture videos and metadata from Twitter, YouTube, and direct URLs \\
\hline
Evidence Integrity & Automated SHA-256 hashing with verification tools \\
\hline
Chain of Custody & Immutable, append-only logs for every forensic event \\
\hline
Metadata Extraction & EXIF data, video codecs, bitrates, resolution extraction \\
\hline
Real-time Analytics & Live statistics and metrics dashboard \\
\hline
PDF Reporting & Professional forensic reports with ReportLab \\
\hline
Background Processing & Celery workers with Redis message broker \\
\hline
\end{tabularx}
\end{table}

\section{Team Members}

\begin{table}[H]
\centering
\caption{FEAS Development Team}
\label{tab:team}
\begin{tabular}{|c|l|l|}
\hline
\textbf{\#} & \textbf{Name} & \textbf{Role} \\
\hline
1 & Rana Uzair Ahmad & Lead Developer \\
\hline
2 & Muhammad Usman & Backend Developer \\
\hline
3 & Umae Habiba & Frontend Developer \\
\hline
4 & Hoor ul Ain & QA \& Documentation \\
\hline
5 & Bilal Badar & DevOps \& Integration \\
\hline
\end{tabular}
\end{table}

%==========================================================================
% CHAPTER 2: SYSTEM ARCHITECTURE
%==========================================================================
\chapter{System Architecture}

\section{Overview}

FEAS follows a modern microservices-inspired architecture with clear separation of concerns. The system consists of six primary components orchestrated through Docker Compose.

\section{Architecture Diagram}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    node distance=1.5cm,
    box/.style={rectangle, draw=primaryblue, fill=lightgray, text width=3cm, text centered, minimum height=1cm, font=\small},
    bigbox/.style={rectangle, draw=secondaryblue, fill=lightgray, text width=4cm, text centered, minimum height=1.5cm, font=\small},
    arrow/.style={->, >=stealth, thick, primaryblue},
    dashedarrow/.style={->, >=stealth, dashed, thick, secondaryblue}
]

% Client Layer
\node[box, fill=accentblue!20] (client) {Client Browser\\(React Frontend)};

% API Layer
\node[bigbox, below=of client] (api) {FastAPI Backend\\Port 8000};

% Processing Layer
\node[box, below left=2cm and -0.5cm of api] (celery) {Celery Worker};
\node[box, below right=2cm and -0.5cm of api] (beat) {Celery Beat};

% Data Layer
\node[box, below=3cm of api] (redis) {Redis\\Port 6379};
\node[box, left=of redis] (postgres) {PostgreSQL\\Port 5432};
\node[box, right=of redis] (storage) {Evidence\\Storage};

% Frontend
\node[box, fill=successgreen!20, right=2cm of client] (frontend) {Frontend Server\\Port 3000};

% Arrows
\draw[arrow] (client) -- (api);
\draw[arrow] (api) -- (celery);
\draw[arrow] (api) -- (beat);
\draw[arrow] (celery) -- (redis);
\draw[arrow] (beat) -- (redis);
\draw[arrow] (api) -- (postgres);
\draw[arrow] (celery) -- (postgres);
\draw[arrow] (celery) -- (storage);
\draw[dashedarrow] (client) -- (frontend);

\end{tikzpicture}
\caption{FEAS System Architecture Overview}
\label{fig:architecture}
\end{figure}

\section{Component Details}

\subsection{Backend (FastAPI)}

The backend is built with FastAPI 0.115, a modern Python web framework that provides:

\begin{itemize}[leftmargin=*]
    \item Automatic API documentation (Swagger/OpenAPI)
    \item Type validation with Pydantic
    \item Async support for high-performance operations
    \item Dependency injection system
\end{itemize}

\subsubsection{Project Structure}

\begin{lstlisting}[style=bashstyle, caption={Backend Directory Structure}]
backend/
+-- app/
|   +-- api/v1/endpoints/    # REST API routes
|   |   +-- jobs.py          # Job submission & monitoring
|   |   +-- auth.py          # Authentication endpoints
|   |   +-- dashboard.py     # Analytics & statistics
|   |   +-- profile.py       # User profile management
|   +-- core/                # Core utilities
|   |   +-- config.py        # Pydantic settings
|   |   +-- logger.py        # Forensic logging
|   |   +-- security.py      # Auth & authorization
|   +-- db/                  # Database layer
|   |   +-- base.py          # SQLAlchemy base
|   |   +-- session.py       # DB session management
|   +-- models/              # Data models
|   |   +-- schemas.py       # Pydantic schemas
|   |   +-- sql_models.py    # SQLAlchemy models
|   +-- pipelines/           # Processing pipelines
|   |   +-- url_pipeline.py  # URL acquisition
|   |   +-- upload_pipeline.py # File upload
|   |   +-- unified_pipeline.py # Main forensic flow
|   +-- services/            # Business logic
|   |   +-- downloader.py    # yt-dlp wrapper
|   |   +-- metadata.py      # Metadata extraction
|   |   +-- hashing.py       # SHA-256 hashing
|   |   +-- chain_of_custody.py # Audit logging
|   |   +-- pdf_generator.py # ReportLab PDF
|   +-- storage/             # Storage backends
|   +-- workers/             # Celery tasks
+-- Dockerfile
+-- docker-compose.yml
+-- requirements.txt
\end{lstlisting}

\subsection{Frontend (React)}

The frontend is built with React 18.2 and provides:

\begin{itemize}[leftmargin=*]
    \item Modern, responsive UI with Styled Components
    \item Three theme options (Cyber, Dark, Light)
    \item Real-time job monitoring with React Query
    \item Drag-and-drop file uploads
    \item Interactive evidence viewer
\end{itemize}

\subsection{Database (PostgreSQL)}

PostgreSQL 15 stores:

\begin{itemize}[leftmargin=*]
    \item User accounts and profiles
    \item Job metadata and status
    \item Chain of custody entries
    \item Evidence metadata
\end{itemize}

\subsection{Message Broker (Redis)}

Redis 7 serves as:

\begin{itemize}[leftmargin=*]
    \item Celery message broker
    \item Result backend for task status
    \item Optional caching layer
\end{itemize}

\subsection{Background Workers (Celery)}

Celery 5.3 handles:

\begin{itemize}[leftmargin=*]
    \item Asynchronous URL downloads
    \item File processing tasks
    \item PDF report generation
    \item Scheduled cleanup tasks
\end{itemize}

%==========================================================================
% CHAPTER 3: INSTALLATION AND CONFIGURATION
%==========================================================================
\chapter{Installation and Configuration}

\section{Prerequisites}

\subsection{System Requirements}

\begin{table}[H]
\centering
\caption{System Requirements}
\label{tab:requirements}
\begin{tabular}{|l|l|}
\hline
\textbf{Component} & \textbf{Requirement} \\
\hline
Operating System & Linux (Ubuntu 20.04+), macOS, Windows 10+ \\
\hline
Docker & Version 20.10+ \\
\hline
Docker Compose & Version 2.0+ \\
\hline
Python & Version 3.11+ (for manual setup) \\
\hline
Node.js & Version 18+ (for manual setup) \\
\hline
RAM & Minimum 4GB, Recommended 8GB \\
\hline
Disk Space & Minimum 10GB free space \\
\hline
\end{tabular}
\end{table}

\section{Environment Configuration}

\subsection{Backend Environment Variables}

Create a \texttt{.env} file in the \texttt{backend/} directory with the following configuration:

\begin{lstlisting}[style=codestyle, language=bash, caption={Complete .env Configuration}]
# ===========================================
# DATABASE CONFIGURATION
# ===========================================
# Set USE_SQLITE=true for development/testing
# Otherwise, PostgreSQL will be used
USE_SQLITE=false

POSTGRES_SERVER=localhost
POSTGRES_USER=forensic
POSTGRES_PASSWORD=your_secure_password
POSTGRES_DB=forensic_db
POSTGRES_PORT=5432
DATABASE_URL=postgresql://forensic:your_secure_password@localhost:5432/forensic_db

# ===========================================
# REDIS CONFIGURATION
# ===========================================
REDIS_HOST=localhost
REDIS_PORT=6379

# ===========================================
# CELERY CONFIGURATION
# ===========================================
# Set USE_CELERY=false to use FastAPI BackgroundTasks
# This is useful for simple development setups
USE_CELERY=true

# ===========================================
# SECURITY CONFIGURATION
# ===========================================
# IMPORTANT: Generate a strong secret key for production!
# Use: python -c "import secrets; print(secrets.token_urlsafe(32))"
SECRET_KEY=your-secret-key-change-in-production
ACCESS_TOKEN_EXPIRE_MINUTES=11520  # 8 days

# ===========================================
# DEFAULT ADMIN CREDENTIALS
# ===========================================
# WARNING: Change these immediately after first login!
DEFAULT_ADMIN_EMAIL=admin@feas.local
DEFAULT_ADMIN_PASSWORD=admin123

# ===========================================
# STORAGE CONFIGURATION
# ===========================================
STORAGE_TYPE=local  # Options: 'local' or 's3'
LOCAL_STORAGE_PATH=./evidence_storage
MAX_FILE_SIZE=524288000  # 500MB in bytes

# ===========================================
# S3 STORAGE (Optional)
# ===========================================
# Only needed if STORAGE_TYPE=s3
S3_ENDPOINT=https://s3.amazonaws.com
S3_ACCESS_KEY=your_access_key
S3_SECRET_KEY=your_secret_key
S3_BUCKET_NAME=forensic-evidence
S3_REGION=us-east-1

# ===========================================
# LOGGING CONFIGURATION
# ===========================================
LOG_LEVEL=INFO
CHAIN_OF_CUSTODY_LOG_PATH=./chain_of_custody.log

# ===========================================
# RATE LIMITING
# ===========================================
RATE_LIMIT_PER_MINUTE=60

# ===========================================
# URL ACQUISITION CONFIGURATION
# ===========================================
# List of allowed domains for URL evidence acquisition
# Add domains as a JSON array
ALLOWED_URL_DOMAINS=["twitter.com","x.com","youtube.com","youtu.be","facebook.com","fb.watch","fb.com","instagram.com"]

# ===========================================
# SOCIAL MEDIA API KEYS (Optional)
# ===========================================
# For enhanced metadata extraction
TWITTER_CONSUMER_KEY=
TWITTER_CONSUMER_SECRET=
FACEBOOK_APP_ID=
FACEBOOK_APP_SECRET=
INSTAGRAM_APP_ID=
INSTAGRAM_APP_SECRET=
\end{lstlisting}

\subsection{Frontend Environment Variables}

Create a \texttt{.env} file in the \texttt{frontend/} directory:

\begin{lstlisting}[style=bashstyle, caption={Frontend .env Configuration}]
REACT_APP_API_URL=http://localhost:8000
\end{lstlisting}

\section{Docker Installation (Recommended)}

\subsection{Step 1: Clone Repository}

\begin{lstlisting}[style=bashstyle, caption={Clone Repository}]
git clone https://github.com/Dynamo2k/FEAS.git
cd FEAS
\end{lstlisting}

\subsection{Step 2: Configure Environment}

\begin{lstlisting}[style=bashstyle, caption={Configure Environment}]
cd backend
cp .env.example .env
# Edit .env with your configuration
nano .env
\end{lstlisting}

\subsection{Step 3: Launch Services}

\begin{lstlisting}[style=bashstyle, caption={Launch with Docker Compose}]
docker-compose up --build -d
\end{lstlisting}

This starts all six services:

\begin{enumerate}[leftmargin=*]
    \item PostgreSQL (port 5432)
    \item Redis (port 6379)
    \item Backend API (port 8000)
    \item Frontend (port 3000)
    \item Celery Worker
    \item Celery Beat
\end{enumerate}

\subsection{Step 4: Verify Installation}

\begin{lstlisting}[style=bashstyle, caption={Verify Services}]
# Check running containers
docker-compose ps

# Check API health
curl http://localhost:8000/health

# Access services
# Frontend: http://localhost:3000
# API Docs: http://localhost:8000/docs
\end{lstlisting}

\section{Manual Installation}

\subsection{Backend Setup}

\begin{lstlisting}[style=bashstyle, caption={Manual Backend Setup}]
cd backend

# Create virtual environment
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate

# Install dependencies
pip install -r requirements.txt

# Install system dependencies (Ubuntu/Debian)
sudo apt-get install ffmpeg libmagic1

# Start the backend
uvicorn app.main:app --reload --host 0.0.0.0 --port 8000

# In separate terminals, start Celery:
celery -A app.workers.celery_app.celery worker --loglevel=info
celery -A app.workers.celery_app.celery beat --loglevel=info
\end{lstlisting}

\subsection{Frontend Setup}

\begin{lstlisting}[style=bashstyle, caption={Manual Frontend Setup}]
cd frontend

# Install dependencies
npm install

# Start development server
npm start
\end{lstlisting}

%==========================================================================
% CHAPTER 4: URL ACQUISITION WORKFLOW
%==========================================================================
\chapter{URL Acquisition Workflow}

\section{Overview}

The URL acquisition system allows investigators to capture evidence from social media platforms. The system validates URLs, downloads content, extracts metadata, computes hashes, and generates forensic reports.

\section{Supported Platforms}

\begin{table}[H]
\centering
\caption{Supported Platforms for URL Acquisition}
\label{tab:platforms}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Platform} & \textbf{Supported URLs} & \textbf{Status} \\
\hline
Twitter/X & twitter.com, x.com & \textcolor{successgreen}{\ding{51}} Full Support \\
\hline
YouTube & youtube.com, youtu.be & \textcolor{successgreen}{\ding{51}} Full Support \\
\hline
Facebook & facebook.com, fb.watch, fb.com & \textcolor{successgreen}{\ding{51}} Full Support \\
\hline
Instagram & instagram.com & \textcolor{successgreen}{\ding{51}} Full Support \\
\hline
\end{tabular}
\end{table}

\section{Workflow Diagram}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    node distance=1.2cm,
    process/.style={rectangle, draw=primaryblue, fill=lightgray, text width=3cm, text centered, minimum height=0.8cm, font=\footnotesize},
    decision/.style={diamond, draw=secondaryblue, fill=accentblue!20, text width=2cm, text centered, aspect=2, font=\footnotesize},
    startstop/.style={ellipse, draw=primaryblue, fill=successgreen!20, text width=2cm, text centered, font=\footnotesize},
    arrow/.style={->, >=stealth, thick}
]

% Nodes
\node[startstop] (start) {Start};
\node[process, below=of start] (submit) {Submit URL};
\node[decision, below=of submit] (validate) {URL Valid?};
\node[process, below=of validate] (download) {Download Content};
\node[process, below=of download] (hash) {Compute SHA-256};
\node[process, below=of hash] (metadata) {Extract Metadata};
\node[process, below=of metadata] (store) {Store Evidence};
\node[process, below=of store] (report) {Generate PDF};
\node[startstop, below=of report] (end) {Complete};

% Error branch
\node[process, right=2cm of validate, fill=errorred!20] (error) {Return Error};

% Arrows
\draw[arrow] (start) -- (submit);
\draw[arrow] (submit) -- (validate);
\draw[arrow] (validate) -- node[left] {Yes} (download);
\draw[arrow] (validate) -- node[above] {No} (error);
\draw[arrow] (download) -- (hash);
\draw[arrow] (hash) -- (metadata);
\draw[arrow] (metadata) -- (store);
\draw[arrow] (store) -- (report);
\draw[arrow] (report) -- (end);

\end{tikzpicture}
\caption{URL Acquisition Workflow Flowchart}
\label{fig:url-workflow}
\end{figure}

\section{API Endpoint}

\subsection{Submit URL Job}

\begin{lstlisting}[style=codestyle, language=bash, caption={URL Submission API}]
POST /api/v1/jobs/url
Content-Type: application/json
Authorization: Bearer <access_token>

{
    "url": "https://twitter.com/user/status/1234567890",
    "investigator_id": "INV-001",
    "case_number": "CASE-2024-001",
    "notes": "Evidence for investigation"
}
\end{lstlisting}

\subsection{Response}

\begin{lstlisting}[style=codestyle, language=json, caption={URL Submission Response}]
{
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "status": "pending",
    "source": "url",
    "original_url": "https://twitter.com/user/status/1234567890",
    "investigator_id": "INV-001",
    "case_number": "CASE-2024-001",
    "stage": "Initialization",
    "progress": 0,
    "created_at": "2024-01-15T10:30:00Z"
}
\end{lstlisting}

\section{URL Pipeline Code}

\begin{lstlisting}[style=codestyle, language=Python, caption={URL Pipeline Implementation}]
class URLPipeline:
    """Pipeline for processing URLs"""
    
    def __init__(self):
        self.downloader = URLDownloader()
        self.unified_pipeline = UnifiedForensicPipeline()
    
    async def process_url(self, 
                         url: str, 
                         job_id: str, 
                         investigator_id: str, 
                         case_number: str = None) -> Dict[str, Any]:
        
        db: Session = SessionLocal()
        job = db.query(Job).filter(Job.id == job_id).first()
        
        try:
            # Stage 1: Validation & Status Update
            job.status = "processing"
            job.stage = "URL Validation"
            job.progress = 5.0
            db.commit()

            validation = self.downloader.validate_url(url)
            if not validation:
                raise ValueError("URL validation failed")
            
            platform = self.downloader.detect_platform(url)
            platform_str = platform.value if platform else 'web'
            
            # Stage 2: Download
            job.stage = "Downloading"
            job.progress = 15.0
            db.commit()
            
            download_result = await self.downloader.download(url)
            
            if not download_result['success']:
                raise Exception(f"Download failed: {download_result.get('error')}")
            
            # Stage 3: Unified Processing
            process_result = await self.unified_pipeline.process(
                file_path=download_result['file_path'],
                job_id=job_id,
                investigator_id=investigator_id,
                source='url',
                filename=os.path.basename(download_result['file_path']),
                original_url=url,
                platform_info={
                    'platform': platform_str,
                    'metadata': download_result.get('platform_metadata')
                }
            )
            
            return process_result
            
        except Exception as e:
            logger.error(f"URL pipeline failed for job {job_id}: {str(e)}")
            job.status = 'failed'
            job.notes = str(e)
            db.commit()
            return {'success': False, 'error': str(e)}
        finally:
            db.close()
\end{lstlisting}

\section{Processing Modes}

FEAS supports two processing modes for URL acquisition:

\subsection{Celery Mode (Production)}

\begin{lstlisting}[style=bashstyle, caption={Enable Celery Mode}]
# In .env file
USE_CELERY=true
REDIS_HOST=localhost
REDIS_PORT=6379
\end{lstlisting}

\textbf{Requirements:}
\begin{itemize}[leftmargin=*]
    \item Redis server running
    \item Celery worker: \texttt{celery -A app.workers.celery\_app.celery worker --loglevel=info}
    \item Celery beat: \texttt{celery -A app.workers.celery\_app.celery beat --loglevel=info}
\end{itemize}

\subsection{BackgroundTasks Mode (Development)}

\begin{lstlisting}[style=bashstyle, caption={Enable BackgroundTasks Mode}]
# In .env file
USE_CELERY=false
\end{lstlisting}

\textbf{Benefits:}
\begin{itemize}[leftmargin=*]
    \item No Redis required
    \item No Celery worker required
    \item Simpler setup for development
\end{itemize}

%==========================================================================
% CHAPTER 5: FILE UPLOAD PROCESSING
%==========================================================================
\chapter{File Upload Processing}

\section{Supported File Types}

\begin{table}[H]
\centering
\caption{Supported File Types for Upload}
\label{tab:filetypes}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Category} & \textbf{Extensions} & \textbf{MIME Types} \\
\hline
Images & .jpg, .jpeg, .png, .heic, .heif & image/jpeg, image/png, image/heic \\
\hline
Videos & .mp4, .mov, .avi & video/mp4, video/quicktime \\
\hline
Audio & .mp3, .wav & audio/mpeg, audio/wav \\
\hline
Documents & .pdf, .txt & application/pdf, text/plain \\
\hline
Archives & .zip & application/zip \\
\hline
\end{tabular}
\end{table}

\section{Upload Workflow}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    node distance=1cm,
    process/.style={rectangle, draw=primaryblue, fill=lightgray, text width=2.8cm, text centered, minimum height=0.7cm, font=\footnotesize},
    arrow/.style={->, >=stealth, thick}
]

% Row 1
\node[process] (upload) {File Upload};
\node[process, right=0.5cm of upload] (validate) {Validate File};
\node[process, right=0.5cm of validate] (temp) {Save to Temp};
\node[process, right=0.5cm of temp] (hash) {Compute Hash};

% Row 2
\node[process, below=1cm of upload] (meta) {Extract Metadata};
\node[process, right=0.5cm of meta] (store) {Store Evidence};
\node[process, right=0.5cm of store] (report) {Generate PDF};
\node[process, right=0.5cm of report] (complete) {Complete};

% Arrows
\draw[arrow] (upload) -- (validate);
\draw[arrow] (validate) -- (temp);
\draw[arrow] (temp) -- (hash);
\draw[arrow] (hash) -- (meta);
\draw[arrow] (meta) -- (store);
\draw[arrow] (store) -- (report);
\draw[arrow] (report) -- (complete);

\end{tikzpicture}
\caption{File Upload Processing Workflow}
\label{fig:upload-workflow}
\end{figure}

\section{Upload API Endpoint}

\begin{lstlisting}[style=codestyle, language=bash, caption={File Upload API}]
POST /api/v1/jobs/upload
Content-Type: multipart/form-data
Authorization: Bearer <access_token>

Form Data:
- file: <binary file data>
- investigator_id: "INV-001"
- case_number: "CASE-2024-001" (optional)
- notes: "Evidence description" (optional)
\end{lstlisting}

\section{File Validation}

\begin{lstlisting}[style=codestyle, language=Python, caption={File Validation Service}]
class FileValidator:
    """Validates uploaded files for forensic processing"""
    
    ALLOWED_TYPES = {
        "application/pdf", "image/png", "image/jpeg",
        "text/plain", "application/zip", "video/mp4",
        "audio/mpeg", "audio/wav"
    }
    MAX_UPLOAD_MB = 500
    
    def validate_upload_file(self, file: UploadFile) -> Dict[str, Any]:
        """Validate file type, size, and integrity"""
        
        # Check file size
        if file.size > self.MAX_UPLOAD_MB * 1024 * 1024:
            return {
                "valid": False,
                "error": f"File exceeds {self.MAX_UPLOAD_MB}MB limit"
            }
        
        # Check MIME type
        if file.content_type not in self.ALLOWED_TYPES:
            return {
                "valid": False,
                "error": f"File type {file.content_type} not allowed"
            }
        
        return {"valid": True}
\end{lstlisting}

%==========================================================================
% CHAPTER 6: PDF REPORT GENERATION
%==========================================================================
\chapter{PDF Report Generation}

\section{Overview}

FEAS generates professional forensic PDF reports using the ReportLab library. Reports include case details, evidence metadata, SHA-256 hashes, and the complete chain of custody log.

\section{Report Structure}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    node distance=0.3cm,
    section/.style={rectangle, draw=primaryblue, fill=lightgray, text width=8cm, minimum height=0.8cm, font=\small},
    header/.style={rectangle, draw=primaryblue, fill=primaryblue!80, text=white, text width=8cm, minimum height=1cm, font=\small\bfseries}
]

\node[header] (title) {FORENSIC EVIDENCE REPORT};
\node[section, below=of title] (summary) {Report Summary (Job ID, Source, Status, Date)};
\node[section, below=of summary] (case) {Case Information (Investigator, Platform, Dates)};
\node[section, below=of case] (fingerprint) {Digital Fingerprint (SHA-256 Hash, File Details)};
\node[section, below=of fingerprint] (custody) {Chain of Custody (Event Log)};
\node[section, below=of custody] (metadata) {EXIF Metadata (if available)};
\node[section, below=of metadata] (cert) {Certification \& Signatures};
\node[section, below=of cert] (disclaimer) {Disclaimer};

\end{tikzpicture}
\caption{PDF Report Structure}
\label{fig:pdf-structure}
\end{figure}

\section{PDF Generator Code}

\begin{lstlisting}[style=codestyle, language=Python, caption={PDF Report Generator (Excerpt)}]
class PDFReportGenerator:
    """Generates professional forensic PDF reports"""
    
    @staticmethod
    def generate_report(job_details: JobDetailsResponse) -> str:
        """Generate professional PDF report from job details"""
        try:
            # Create temporary file for PDF
            temp_file = tempfile.NamedTemporaryFile(
                delete=False, suffix='.pdf'
            )
            temp_path = temp_file.name
            temp_file.close()
            
            # Create document with adjusted margins
            doc = SimpleDocTemplate(
                temp_path,
                pagesize=letter,
                rightMargin=inch,
                leftMargin=inch,
                topMargin=1.3*inch,
                bottomMargin=0.8*inch
            )
            
            styles = PDFReportGenerator._create_styles()
            story = []
            
            # TITLE PAGE
            story.append(Spacer(1, 60))
            story.append(Paragraph(
                "FORENSIC EVIDENCE REPORT",
                styles['ReportTitle']
            ))
            
            # REPORT SUMMARY
            summary_data = [
                ["REPORT SUMMARY", ""],
                ["Job Reference:", job_details.job_id],
                ["Evidence Source:", f"{source_str} ({platform_str})"],
                ["Status:", job_details.status.upper()],
                ["Report Generated:", datetime.utcnow().strftime(
                    '%Y-%m-%d %H:%M:%S UTC'
                )],
            ]
            
            # DIGITAL FINGERPRINT (SHA-256)
            hash_data = [
                ["SHA-256 Hash:", job_details.metadata.sha256_hash],
                ["File Name:", job_details.metadata.file_name],
                ["File Size:", size_str],
                ["MIME Type:", job_details.metadata.mime_type],
            ]
            
            # CHAIN OF CUSTODY
            for idx, entry in enumerate(job_details.chain_of_custody, 1):
                custody_data.append([
                    str(idx),
                    entry.timestamp.strftime('%Y-%m-%d %H:%M:%S'),
                    entry.event,
                    entry.investigator_id,
                    str(entry.details)[:80]
                ])
            
            # Build PDF with header/footer
            doc.build(story, 
                     onFirstPage=PDFReportGenerator.create_header_footer,
                     onLaterPages=PDFReportGenerator.create_header_footer)
            
            logger.info(f"PDF report generated: {temp_path}")
            return temp_path
            
        except Exception as e:
            logger.error(f"PDF generation failed: {str(e)}")
            raise
\end{lstlisting}

\section{Report Features}

\begin{itemize}[leftmargin=*]
    \item \textbf{Professional Header/Footer}: Page numbers, timestamps, confidentiality notice
    \item \textbf{Color-coded Sections}: Visual distinction between report sections
    \item \textbf{Watermark}: Subtle ``FEAS REPORT'' watermark for authenticity
    \item \textbf{SHA-256 Display}: Monospace font for hash values
    \item \textbf{Chain of Custody Table}: Chronological event log
    \item \textbf{Signature Areas}: Spaces for examiner and supervisor signatures
    \item \textbf{Legal Disclaimer}: Standard forensic evidence disclaimer
\end{itemize}

\section{Accessing Reports}

\begin{lstlisting}[style=bashstyle, caption={Download PDF Report via API}]
GET /api/v1/jobs/{job_id}/report
Authorization: Bearer <access_token>

# Response: PDF file download
Content-Type: application/pdf
Content-Disposition: attachment; filename="Forensic_Report_{job_id}.pdf"
\end{lstlisting}

%==========================================================================
% CHAPTER 7: CHAIN OF CUSTODY
%==========================================================================
\chapter{Chain of Custody}

\section{Overview}

The Chain of Custody is an immutable, append-only log that records every action taken on a piece of evidence. This is critical for maintaining legal admissibility in court proceedings.

\section{Event Types}

\begin{table}[H]
\centering
\caption{Chain of Custody Event Types}
\label{tab:events}
\begin{tabularx}{\textwidth}{|l|X|}
\hline
\textbf{Event} & \textbf{Description} \\
\hline
ACQUISITION & Evidence acquired from URL or file upload \\
\hline
HASH\_CALCULATED & SHA-256 hash computed for integrity verification \\
\hline
METADATA\_EXTRACTED & EXIF and media metadata extracted \\
\hline
EVIDENCE\_STORED & Evidence file stored in storage backend \\
\hline
REPORT\_GENERATED & PDF forensic report generated \\
\hline
INTEGRITY\_VERIFIED & Hash verification performed \\
\hline
EVIDENCE\_ACCESSED & Evidence file accessed by investigator \\
\hline
\end{tabularx}
\end{table}

\section{Database Model}

\begin{lstlisting}[style=codestyle, language=Python, caption={Chain of Custody SQL Model}]
class ChainOfCustody(Base):
    """Immutable chain of custody log entry"""
    __tablename__ = "chain_of_custody"
    
    id = Column(Integer, primary_key=True, index=True)
    job_id = Column(String, ForeignKey("jobs.id"), nullable=False)
    timestamp = Column(DateTime, default=datetime.utcnow)
    event = Column(String, nullable=False)
    investigator_id = Column(String, nullable=False)
    details = Column(JSON, nullable=True)
    hash_verification = Column(String, nullable=True)
    
    # Relationship
    job = relationship("Job", back_populates="chain_of_custody")
\end{lstlisting}

\section{Logging Implementation}

\begin{lstlisting}[style=codestyle, language=Python, caption={Forensic Logger}]
class ForensicLogger:
    """Handles all forensic logging operations"""
    
    @staticmethod
    def log_acquisition(job_id: str, source: str, 
                       investigator_id: str, **kwargs):
        """Log evidence acquisition event"""
        db = SessionLocal()
        try:
            entry = ChainOfCustody(
                job_id=job_id,
                event="ACQUISITION",
                investigator_id=investigator_id,
                details={
                    "source": source,
                    "url": kwargs.get("url"),
                    "filename": kwargs.get("filename")
                }
            )
            db.add(entry)
            db.commit()
        finally:
            db.close()
    
    @staticmethod
    def log_hash_calculation(job_id: str, investigator_id: str,
                            hash_value: str, algorithm: str = "SHA256"):
        """Log hash calculation event"""
        db = SessionLocal()
        try:
            entry = ChainOfCustody(
                job_id=job_id,
                event="HASH_CALCULATED",
                investigator_id=investigator_id,
                details={"algorithm": algorithm},
                hash_verification=hash_value
            )
            db.add(entry)
            db.commit()
        finally:
            db.close()
\end{lstlisting}

%==========================================================================
% CHAPTER 8: API REFERENCE
%==========================================================================
\chapter{API Reference}

\section{Authentication Endpoints}

\begin{table}[H]
\centering
\caption{Authentication API Endpoints}
\label{tab:auth-api}
\begin{tabularx}{\textwidth}{|l|l|X|}
\hline
\textbf{Method} & \textbf{Endpoint} & \textbf{Description} \\
\hline
POST & /api/v1/auth/register & Register new user account \\
\hline
POST & /api/v1/auth/login & Login and receive JWT token \\
\hline
GET & /api/v1/auth/me & Get current authenticated user \\
\hline
POST & /api/v1/auth/logout & Logout (client-side token removal) \\
\hline
\end{tabularx}
\end{table}

\section{Jobs Endpoints}

\begin{table}[H]
\centering
\caption{Jobs API Endpoints}
\label{tab:jobs-api}
\begin{tabularx}{\textwidth}{|l|l|X|}
\hline
\textbf{Method} & \textbf{Endpoint} & \textbf{Description} \\
\hline
POST & /api/v1/jobs/url & Submit URL for evidence acquisition \\
\hline
POST & /api/v1/jobs/upload & Upload local file as evidence \\
\hline
GET & /api/v1/jobs & List all jobs \\
\hline
GET & /api/v1/jobs/\{job\_id\}/status & Get job status \\
\hline
GET & /api/v1/jobs/\{job\_id\}/details & Get detailed job info \\
\hline
POST & /api/v1/jobs/\{job\_id\}/verify & Verify file integrity \\
\hline
GET & /api/v1/jobs/\{job\_id\}/report & Download PDF report \\
\hline
GET & /api/v1/analytics & Get analytics data \\
\hline
\end{tabularx}
\end{table}

\section{Profile Endpoints}

\begin{table}[H]
\centering
\caption{Profile API Endpoints}
\label{tab:profile-api}
\begin{tabularx}{\textwidth}{|l|l|X|}
\hline
\textbf{Method} & \textbf{Endpoint} & \textbf{Description} \\
\hline
GET & /api/v1/profile/ & Get user profile information \\
\hline
PATCH & /api/v1/profile/ & Update profile information \\
\hline
\end{tabularx}
\end{table}

\section{Dashboard Endpoints}

\begin{table}[H]
\centering
\caption{Dashboard API Endpoints}
\label{tab:dashboard-api}
\begin{tabularx}{\textwidth}{|l|l|X|}
\hline
\textbf{Method} & \textbf{Endpoint} & \textbf{Description} \\
\hline
GET & /api/v1/dashboard/cards & Get dashboard statistics \\
\hline
GET & /api/v1/dashboard/activity & Get recent chain of custody events \\
\hline
\end{tabularx}
\end{table}

%==========================================================================
% CHAPTER 9: SECURITY
%==========================================================================
\chapter{Security Considerations}

\section{Authentication Security}

\begin{itemize}[leftmargin=*]
    \item \textbf{Password Hashing}: Bcrypt with automatic salt generation
    \item \textbf{JWT Tokens}: Configurable expiration (default 8 days)
    \item \textbf{Secret Key}: Use strong, randomly generated keys in production
\end{itemize}

\begin{lstlisting}[style=bashstyle, caption={Generate Secure Secret Key}]
python -c "import secrets; print(secrets.token_urlsafe(32))"
\end{lstlisting}

\section{URL Validation}

All URLs are validated against a whitelist before processing:

\begin{lstlisting}[style=codestyle, language=Python, caption={URL Validation}]
ALLOWED_URL_DOMAINS = [
    "twitter.com", "x.com",
    "youtube.com", "youtu.be",
    "facebook.com", "fb.watch", "fb.com",
    "instagram.com"
]

def validate_url(self, url: str) -> bool:
    """Validate URL against whitelist"""
    parsed = urlparse(url)
    domain = parsed.netloc.lower().lstrip('www.')
    return domain in self.ALLOWED_URL_DOMAINS
\end{lstlisting}

\section{Evidence Integrity}

\begin{itemize}[leftmargin=*]
    \item \textbf{SHA-256 Hashing}: All evidence is hashed upon acquisition
    \item \textbf{Verification}: Hash comparison to detect tampering
    \item \textbf{Immutable Logs}: Chain of custody entries cannot be modified
\end{itemize}

\section{Best Practices}

\begin{enumerate}[leftmargin=*]
    \item Change default admin credentials immediately after installation
    \item Use HTTPS in production environments
    \item Store secrets using environment variables or secrets management
    \item Regularly backup the database
    \item Monitor access logs for suspicious activity
    \item Keep all dependencies updated
\end{enumerate}

%==========================================================================
% CHAPTER 10: TROUBLESHOOTING
%==========================================================================
\chapter{Troubleshooting}

\section{Common Issues}

\subsection{Jobs Stuck at 0\% / Pending}

\textbf{Cause}: Background processing is not running properly.

\textbf{Solutions}:

\begin{enumerate}[leftmargin=*]
    \item \textbf{If using Celery mode}:
    \begin{lstlisting}[style=bashstyle]
# Ensure Redis is running
redis-cli ping  # Should return PONG

# Restart Celery worker
docker-compose restart celery-worker
    \end{lstlisting}
    
    \item \textbf{Switch to BackgroundTasks mode}:
    \begin{lstlisting}[style=bashstyle]
# In .env file
USE_CELERY=false
# Restart backend server
    \end{lstlisting}
\end{enumerate}

\subsection{Database Connection Error}

\textbf{Error}: \texttt{sqlalchemy.exc.OperationalError: could not connect to server}

\textbf{Solutions}:
\begin{itemize}[leftmargin=*]
    \item Verify PostgreSQL is running: \texttt{docker-compose ps}
    \item Check database credentials in \texttt{.env}
    \item For development, use SQLite: \texttt{USE\_SQLITE=true}
\end{itemize}

\subsection{PDF Generation Fails}

\textbf{Error}: Playwright or ReportLab errors

\textbf{Solutions}:
\begin{lstlisting}[style=bashstyle]
# Install Playwright browsers
playwright install chromium

# Rebuild Docker container
docker-compose build backend
\end{lstlisting}

\subsection{Video Download Fails}

\textbf{Error}: \texttt{yt-dlp error} or download timeout

\textbf{Solutions}:
\begin{lstlisting}[style=bashstyle]
# Update yt-dlp
pip install --upgrade yt-dlp

# Check if URL is from supported platform
# Verify internet connectivity
\end{lstlisting}

\subsection{CORS Errors}

\textbf{Error}: Network Error or CORS errors in browser

\textbf{Solutions}:
\begin{itemize}[leftmargin=*]
    \item Verify backend is running: \texttt{curl http://localhost:8000/health}
    \item Check \texttt{REACT\_APP\_API\_URL} in frontend \texttt{.env}
    \item Ensure CORS is configured in \texttt{backend/app/main.py}
\end{itemize}

%==========================================================================
% CHAPTER 11: APPENDIX
%==========================================================================
\chapter{Appendix}

\section{Complete .env Template}

\begin{lstlisting}[style=codestyle, language=bash, caption={Complete .env Template}]
# Database Configuration
USE_SQLITE=false
POSTGRES_SERVER=localhost
POSTGRES_USER=forensic
POSTGRES_PASSWORD=your_secure_password
POSTGRES_DB=forensic_db
POSTGRES_PORT=5432
DATABASE_URL=postgresql://forensic:your_secure_password@localhost:5432/forensic_db

# Redis Configuration
REDIS_HOST=localhost
REDIS_PORT=6379

# Celery Configuration
USE_CELERY=true

# Security
SECRET_KEY=your-secret-key-change-in-production
ACCESS_TOKEN_EXPIRE_MINUTES=11520

# Default Admin Credentials
DEFAULT_ADMIN_EMAIL=admin@feas.local
DEFAULT_ADMIN_PASSWORD=admin123

# Storage
STORAGE_TYPE=local
LOCAL_STORAGE_PATH=./evidence_storage
MAX_FILE_SIZE=524288000

# S3 (Optional)
S3_ENDPOINT=https://s3.amazonaws.com
S3_ACCESS_KEY=your_access_key
S3_SECRET_KEY=your_secret_key
S3_BUCKET_NAME=forensic-evidence
S3_REGION=us-east-1

# Logging
LOG_LEVEL=INFO
CHAIN_OF_CUSTODY_LOG_PATH=./chain_of_custody.log

# Rate Limiting
RATE_LIMIT_PER_MINUTE=60

# Allowed Domains
ALLOWED_URL_DOMAINS=["twitter.com","x.com","youtube.com","youtu.be","facebook.com","fb.watch","fb.com","instagram.com"]
\end{lstlisting}

\section{Docker Compose Configuration}

\begin{lstlisting}[style=codestyle, language=yaml, caption={Docker Compose Services}]
version: '3.8'

services:
  postgres:
    image: postgres:15
    ports:
      - "5432:5432"
    environment:
      POSTGRES_USER: forensic
      POSTGRES_PASSWORD: password
      POSTGRES_DB: forensic_db

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

  backend:
    build: .
    ports:
      - "8000:8000"
    depends_on:
      - postgres
      - redis

  frontend:
    build: ../frontend
    ports:
      - "3000:3000"

  celery-worker:
    build: .
    command: celery -A app.workers.celery_app.celery worker
    depends_on:
      - redis
      - postgres

  celery-beat:
    build: .
    command: celery -A app.workers.celery_app.celery beat
    depends_on:
      - redis
\end{lstlisting}

\section{Technology Stack Summary}

\begin{table}[H]
\centering
\caption{Complete Technology Stack}
\label{tab:tech-stack}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Layer} & \textbf{Technology} & \textbf{Version} \\
\hline
Backend & Python & 3.11 \\
Backend & FastAPI & 0.115 \\
Backend & SQLAlchemy & 2.0 \\
Backend & Celery & 5.3 \\
Backend & ReportLab & 4.0+ \\
Backend & yt-dlp & Latest \\
\hline
Frontend & React & 18.2 \\
Frontend & Styled Components & 6.1 \\
Frontend & React Query & 3.39 \\
Frontend & Axios & 1.6 \\
Frontend & Zustand & 4.4 \\
\hline
Database & PostgreSQL & 15 \\
Database & SQLite & 3 (dev) \\
\hline
Infrastructure & Docker & 20.10+ \\
Infrastructure & Redis & 7 \\
\hline
\end{tabular}
\end{table}

%==========================================================================
% END OF DOCUMENT
%==========================================================================

\end{document}
